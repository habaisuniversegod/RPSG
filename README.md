# RPSG: Reverse Polish Sound Generator (не курва, а потому-что постфиксный)
Короче, так как я поставусил себе линух и флОЧКи тута нет, то генерировать новые саунды Европы для моих пробебриков придётся изворачиваясь и придумывая свои придумки.

**Перевод с даунского:** В общем, эта программа предназначена для т. н. *звукового программирования*, тобишь для синтеза звука при помощи программного кода. А вообще, есть целые жанры, посвящённые такой музыке, к примеру тот же *bytebeat*, или как там его. Отсюда сразу следует плюс: *не нужно хранить звуковые семплы и тратить место, если можно хранить инструкцию (программу), как звук создать.* Полезно для тех, кто самоудовлетворяется на демосцены и прочие девиации.

## Как начать?

Первым делом надо собрать проект, а так как я теперь линуксоид, то и инструкция будет для Линукса.

Сначала раздобудьте где-нибудь CMake. Я хз, идёт ли он с каими-то дистрибутивами сразу, но лично я из магазина Debian что-то скачал, там гайды сами найдёте. А, и Git тоже нужен.

Зайдите в терминал и готовьтесь копипастить следующие команды: скопируйте репозиторий


    habaisuniversegod@habacomp:~$ git clone https://github.com/habaisuniversegod/RPSG.git

Появится директория `RPSG`. В ней будут файлы со всем стаффом. Перейдём туда:


    habaisuniversegod@habacomp:~$ cd RPSG
    habaisuniversegod@habacomp:~/RPSG$

Можно посмотреть, что там есть:

    habaisuniversegod@habacomp:~/RPSG$ ls
    CMakeLists.txt  eval.h    lexer.cpp  main.cpp   wsave.cpp
    eval.cpp        examples  lexer.h    README.md  wsave.h

Нам это безразлично на самом деле, так что едем дальше.

Создайте новую директорию, где всё и соберётся. Назвать можно как душе заблагорассудится. Потом в неё надо будет зайти:

    habaisuniversegod@habacomp:~/RPSG$ mkdir tmp
    habaisuniversegod@habacomp:~/RPSG$ cd tmp
    habaisuniversegod@habacomp:~/RPSG/tmp$ 

Натравливаем на это дело CMake:

    habaisuniversegod@habacomp:~/RPSG/tmp$ cmake ..

Дальше ждём и если ошибок нет, мы должны получить файлик Makefile:

    habaisuniversegod@habacomp:~/RPSG/tmp$ ls
    CMakeCache.txt  CMakeFiles  cmake_install.cmake  Makefile

Натравливаем утилиту `make` на это добро:

    habaisuniversegod@habacomp:~/RPSG/tmp$ make

Если ошибок нет, то в текущей директории появится исполняемый файл `main`.

Да впринципе готово, его можно хоть щас запустить, но без аргументов оно не попрёт, так что читай доки дальше...

## Запуск

Формат аргументов таков:
    
    ./main <файл с кодом> <частота дискретизации> <длина (в секундах)> <выходной аудио-файл в формате .wav>

Можно проверить примеры из папки `examples`:

    ./main ../examples/ex1-0.4s.txt 44100 0.4 test.wav

В папке с исполняемым файлом появится наш эпичнейший KSHMR Snare или Ride или Open Hat, я хз. Можно открыть в Audacity, позырить, пощёлкать, послушать:

![как выглядит новый саунд европы](res/1.png)

## Краткая документация

Фактически, файл с кодом описывает функцию, на вход которой подаётся номер текущего сэмпла (знак `$`), а результат (в диапазоне от -1 до 1) и будет являться значением этого семпла в аудиофайле. Общее количество сэмплов (в программе можно получить, используя знак `#`) вычисляется по формуле *f * l*, где *f* - частота дискретизации, а *l* - длина в секундах. Однако, что и является ключевой особенностью сей опуса, эта функция описана не привычной нам *инфиксной* записью, тобишь там 2 + 2 * (2 / 2), а с использованием т. н. *обратной польской записи*, в которой оператор стоит после операндов.

**Почему именно ОПЗ?**

Во-первых, потому-что я так захотел :)

А во-вторых, ОПЗ тупо проще вычислять. Все вычисления производятся на стеке, операнды кладутся на него, а операторы берут столько, сколько надо, а после кладут результат обратно. В отличие от инфиксной записи, нет ни скобок, ни какого-либо строго заданного приоритета операций и не нужно строить никакие *абстактные синтаксические деревья* и прочие песнопения со свистоплясками.

**Как понять стек?**

Проще говоря, стек - это как стопка помытых тарелок. Вам всегда сразу доступна самая верхняя из них, а чтобы взять вторую, нужно сначала достать первую и так по аналогии на всю стопку. Это т. н. принцип *LIFO (last in, first out - последним пришёл, первым ушёл)*. А теперь представьте, что на каждой тарелке написаны какие-то числа, которые и будут нашими входными данными, а также есть листик с инструкцией, какие тарелки ложить или какие взять и что с ними сделать. К примеру у нас есть программа:

    положи 2
    положи 2
    сложи

Или на нашем языке будет просто:

    2 2 add

Если мы начали с пустой стопки, то мы действуем так:

1. Вот мы прочли первую инструкцию: `положи 2`. Мы берём кристально чистую, блестящую, вымытую и насухо вытертую тарелку и пишем маркером на ней цифру 2, после чего кладём на стол.

2. Вторая инструкция говорит делать то же самое, поэтому так же пишем 2 и кладём на стол, а так как на столе уже стоит тарелка,то вторую мы кладём поверх первой, по принципу *LIFO*.

3. Третья инструкция говорит нам `сложи`. Мы привыкли, что сложение (знак `+`) мы осуществляем с двумя числами (операндами). В понятной нам инфиксной нотации это будет число слева от плюса, и число справа от плюса. Но в ОПЗ это будут два числа, одно из которых находится на вершине нашего стека, а другое под ней, (когда мы достанем первое, то ко второму получим доступ). Возвращаясь к тарелкам, мы берём верхнюю тарелку с цифрой 2, и берём тарелку под ней, которая стала верхней после того, как мы взяли первую, тоже с цифрой 2, ну и складываем: 2 + 2 = 4. Эти тарелки нам больше не нужны, они отработали своё. Мы берём новую чистую тарелку и пишем на ней 4, и кладём в "стек".

Программа закончилась и поэтому результатом вычислений (тоесть нашей программы) будет самое верхнее значение на стеке, и по-совместительству, единственное. Для всех остальных операций всё работает аналогично, разве что может отличаться количество тарелок, которые мы берём в качестве операндов (может быть две, а может и одна). 

**Операторы**

Кратко пробежимся по всем существующим операторам (прим. "левый" операнд (a) на стеке находится вторым сверху, "правый" операнд - вершина):

Название    | Мнемоника   | Сколько операндов?   | В Си 
:------------|:------------|:--------------------|:------
Сложение    | add   | 2  |  a + b 
Вычитание    | sub   | 2  | a - b
Умножение    | mul   | 2  | a * b
Деление   | div  | 2  | a / b 
Взятие остатка от деления    | mod | 2  | fmod(a, b) 
Абсолютная величина | abs | 1  | abs(a) 
Сигнум  | sgn   | 1  | a == 0 ? 0 : (a > 0 ? 1 : -1) 
Возведение в степень | pow   | 2  | pow(a, b) 
Двоичный логарифм | log2   | 1  | log2(a) 
Десятичный логарифм | log10   | 1  | log10(a) 
Логарифм | log   | 2  | log2(a) / log2(b) 
Квадратный корень | sqrt |1|sqrt(a)
Округление | round|2|round(a * pow(10, b)) / pow (10, b) 
Округление вниз до ближайшего целого | floor |1|floor(a)
Округление вверх до ближайшего целого | ceil |1|ceil(a)
Отрицание | neg |1| -a
Синус | sin |1| sin(a)
Косинус | cos |1 |cos(a)
Тангенс | tan |1| tan(a)
Арксинус | asin |1| asin(a)
 Арккосинус | acos |1 |acos(a)
 Арктангенс| atan |1| atan(a)
 Минимум| min |2| min(a, b)
 Максимум| max |2|max(a, b)

Также в RPSG есть и операторы сравнения. (прим. значение *истина* равно 1.0, *ложь* равно 0.0):
Название | Мнемоника| В Си
:------|:-------|:-----
Равно | equ | a == b
Не равно | neq | a != b
Меньше | less | a < b
Больше | gre | a > b
Меньше или равно | lesseq | a <= b
Больше или равно | greeq | a >= b

Также есть несколько операторов, предназначенных для манипуляций со стеком:
 Мнемоника| Описание
:------|:-------
dup | Дублирует верхнее значение на стеке
swp | Меняет местами верхнее значение со значением, вторым сверху ("левое" и "правое" проще говоря)

**Литералы и значения**

Любой числовой литерал, а также некоторые специальные, называются *значениями*. Когда значение встречается в коде, оно автоматически кладётся на вершину стека. Значение представлено числом с плавающей точкой двойной точности (64-битный `double`)

Примеры числовых литералов: `1`, `0`, `-1.1`, `.5`, `-.1`

Список специальных литералов:

Мнемоника | Описание
:-----|:-----
$ | Номер текущего обрабатываемого сэмпла (независимая переменная)
\# | Количество сэмплов всего
rand | Случайное число от -1 до 1

**Кратко о синтаксисе**

Программа для RPSG - последовательность значений и операторов, разделённых пробелами, переносами строк, табуляциями или прочими пробельными символами. Можно написать программу в одну строку, а можно визуально разбить её переносами строки на отдельные действия.

    $ 1000 div sin 2 div

То же что и

    $ 1000 div
    sin
    2 div

Во втором случае понятнее, что f(x) = sin(x / 1000) / 2




